// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msgtype.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msgtype_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msgtype_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msgtype_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msgtype_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msgtype_2eproto;
class AckResp;
struct AckRespDefaultTypeInternal;
extern AckRespDefaultTypeInternal _AckResp_default_instance_;
class Alive;
struct AliveDefaultTypeInternal;
extern AliveDefaultTypeInternal _Alive_default_instance_;
class Dead;
struct DeadDefaultTypeInternal;
extern DeadDefaultTypeInternal _Dead_default_instance_;
class ErrResp;
struct ErrRespDefaultTypeInternal;
extern ErrRespDefaultTypeInternal _ErrResp_default_instance_;
class IndirectPing;
struct IndirectPingDefaultTypeInternal;
extern IndirectPingDefaultTypeInternal _IndirectPing_default_instance_;
class MessageData;
struct MessageDataDefaultTypeInternal;
extern MessageDataDefaultTypeInternal _MessageData_default_instance_;
class NackResp;
struct NackRespDefaultTypeInternal;
extern NackRespDefaultTypeInternal _NackResp_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class PushNodeState;
struct PushNodeStateDefaultTypeInternal;
extern PushNodeStateDefaultTypeInternal _PushNodeState_default_instance_;
class PushPull;
struct PushPullDefaultTypeInternal;
extern PushPullDefaultTypeInternal _PushPull_default_instance_;
class Suspect;
struct SuspectDefaultTypeInternal;
extern SuspectDefaultTypeInternal _Suspect_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AckResp* Arena::CreateMaybeMessage<::AckResp>(Arena*);
template<> ::Alive* Arena::CreateMaybeMessage<::Alive>(Arena*);
template<> ::Dead* Arena::CreateMaybeMessage<::Dead>(Arena*);
template<> ::ErrResp* Arena::CreateMaybeMessage<::ErrResp>(Arena*);
template<> ::IndirectPing* Arena::CreateMaybeMessage<::IndirectPing>(Arena*);
template<> ::MessageData* Arena::CreateMaybeMessage<::MessageData>(Arena*);
template<> ::NackResp* Arena::CreateMaybeMessage<::NackResp>(Arena*);
template<> ::Ping* Arena::CreateMaybeMessage<::Ping>(Arena*);
template<> ::PushNodeState* Arena::CreateMaybeMessage<::PushNodeState>(Arena*);
template<> ::PushPull* Arena::CreateMaybeMessage<::PushPull>(Arena*);
template<> ::Suspect* Arena::CreateMaybeMessage<::Suspect>(Arena*);
template<> ::User* Arena::CreateMaybeMessage<::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MessageData_MessageType : int {
  MessageData_MessageType_pingMsg = 0,
  MessageData_MessageType_indirectPingMsg = 1,
  MessageData_MessageType_ackRespMsg = 2,
  MessageData_MessageType_suspectMsg = 3,
  MessageData_MessageType_aliveMsg = 4,
  MessageData_MessageType_deadMsg = 5,
  MessageData_MessageType_pushPullMsg = 6,
  MessageData_MessageType_userMsg = 7,
  MessageData_MessageType_nackRespMsg = 8,
  MessageData_MessageType_errMsg = 9,
  MessageData_MessageType_MessageData_MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageData_MessageType_MessageData_MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageData_MessageType_IsValid(int value);
constexpr MessageData_MessageType MessageData_MessageType_MessageType_MIN = MessageData_MessageType_pingMsg;
constexpr MessageData_MessageType MessageData_MessageType_MessageType_MAX = MessageData_MessageType_errMsg;
constexpr int MessageData_MessageType_MessageType_ARRAYSIZE = MessageData_MessageType_MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageData_MessageType_descriptor();
template<typename T>
inline const std::string& MessageData_MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageData_MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageData_MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageData_MessageType_descriptor(), enum_t_value);
}
inline bool MessageData_MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageData_MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageData_MessageType>(
    MessageData_MessageType_descriptor(), name, value);
}
enum PushNodeState_NodeStateType : int {
  PushNodeState_NodeStateType_StateAlive = 0,
  PushNodeState_NodeStateType_StateSuspect = 1,
  PushNodeState_NodeStateType_StateDead = 2,
  PushNodeState_NodeStateType_StateLeft = 3,
  PushNodeState_NodeStateType_PushNodeState_NodeStateType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PushNodeState_NodeStateType_PushNodeState_NodeStateType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PushNodeState_NodeStateType_IsValid(int value);
constexpr PushNodeState_NodeStateType PushNodeState_NodeStateType_NodeStateType_MIN = PushNodeState_NodeStateType_StateAlive;
constexpr PushNodeState_NodeStateType PushNodeState_NodeStateType_NodeStateType_MAX = PushNodeState_NodeStateType_StateLeft;
constexpr int PushNodeState_NodeStateType_NodeStateType_ARRAYSIZE = PushNodeState_NodeStateType_NodeStateType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PushNodeState_NodeStateType_descriptor();
template<typename T>
inline const std::string& PushNodeState_NodeStateType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PushNodeState_NodeStateType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PushNodeState_NodeStateType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PushNodeState_NodeStateType_descriptor(), enum_t_value);
}
inline bool PushNodeState_NodeStateType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PushNodeState_NodeStateType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PushNodeState_NodeStateType>(
    PushNodeState_NodeStateType_descriptor(), name, value);
}
// ===================================================================

class MessageData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MessageData) */ {
 public:
  inline MessageData() : MessageData(nullptr) {}
  ~MessageData() override;
  explicit constexpr MessageData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageData(const MessageData& from);
  MessageData(MessageData&& from) noexcept
    : MessageData() {
    *this = ::std::move(from);
  }

  inline MessageData& operator=(const MessageData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageData& operator=(MessageData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageData& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kPing = 2,
    kIndirectping = 3,
    kAckresp = 4,
    kNackresp = 5,
    kErrresp = 6,
    kSuspect = 7,
    kAlive = 8,
    kDead = 9,
    kPushpull = 10,
    kUser = 11,
    BODY_NOT_SET = 0,
  };

  static inline const MessageData* internal_default_instance() {
    return reinterpret_cast<const MessageData*>(
               &_MessageData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MessageData& a, MessageData& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessageData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MessageData";
  }
  protected:
  explicit MessageData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MessageData_MessageType MessageType;
  static constexpr MessageType pingMsg =
    MessageData_MessageType_pingMsg;
  static constexpr MessageType indirectPingMsg =
    MessageData_MessageType_indirectPingMsg;
  static constexpr MessageType ackRespMsg =
    MessageData_MessageType_ackRespMsg;
  static constexpr MessageType suspectMsg =
    MessageData_MessageType_suspectMsg;
  static constexpr MessageType aliveMsg =
    MessageData_MessageType_aliveMsg;
  static constexpr MessageType deadMsg =
    MessageData_MessageType_deadMsg;
  static constexpr MessageType pushPullMsg =
    MessageData_MessageType_pushPullMsg;
  static constexpr MessageType userMsg =
    MessageData_MessageType_userMsg;
  static constexpr MessageType nackRespMsg =
    MessageData_MessageType_nackRespMsg;
  static constexpr MessageType errMsg =
    MessageData_MessageType_errMsg;
  static inline bool MessageType_IsValid(int value) {
    return MessageData_MessageType_IsValid(value);
  }
  static constexpr MessageType MessageType_MIN =
    MessageData_MessageType_MessageType_MIN;
  static constexpr MessageType MessageType_MAX =
    MessageData_MessageType_MessageType_MAX;
  static constexpr int MessageType_ARRAYSIZE =
    MessageData_MessageType_MessageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MessageType_descriptor() {
    return MessageData_MessageType_descriptor();
  }
  template<typename T>
  static inline const std::string& MessageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MessageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MessageType_Name.");
    return MessageData_MessageType_Name(enum_t_value);
  }
  static inline bool MessageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MessageType* value) {
    return MessageData_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kPingFieldNumber = 2,
    kIndirectpingFieldNumber = 3,
    kAckrespFieldNumber = 4,
    kNackrespFieldNumber = 5,
    kErrrespFieldNumber = 6,
    kSuspectFieldNumber = 7,
    kAliveFieldNumber = 8,
    kDeadFieldNumber = 9,
    kPushpullFieldNumber = 10,
    kUserFieldNumber = 11,
  };
  // .MessageData.MessageType Head = 1;
  void clear_head();
  ::MessageData_MessageType head() const;
  void set_head(::MessageData_MessageType value);
  private:
  ::MessageData_MessageType _internal_head() const;
  void _internal_set_head(::MessageData_MessageType value);
  public:

  // .Ping ping = 2;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::Ping& ping() const;
  PROTOBUF_NODISCARD ::Ping* release_ping();
  ::Ping* mutable_ping();
  void set_allocated_ping(::Ping* ping);
  private:
  const ::Ping& _internal_ping() const;
  ::Ping* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::Ping* ping);
  ::Ping* unsafe_arena_release_ping();

  // .IndirectPing indirectping = 3;
  bool has_indirectping() const;
  private:
  bool _internal_has_indirectping() const;
  public:
  void clear_indirectping();
  const ::IndirectPing& indirectping() const;
  PROTOBUF_NODISCARD ::IndirectPing* release_indirectping();
  ::IndirectPing* mutable_indirectping();
  void set_allocated_indirectping(::IndirectPing* indirectping);
  private:
  const ::IndirectPing& _internal_indirectping() const;
  ::IndirectPing* _internal_mutable_indirectping();
  public:
  void unsafe_arena_set_allocated_indirectping(
      ::IndirectPing* indirectping);
  ::IndirectPing* unsafe_arena_release_indirectping();

  // .AckResp ackresp = 4;
  bool has_ackresp() const;
  private:
  bool _internal_has_ackresp() const;
  public:
  void clear_ackresp();
  const ::AckResp& ackresp() const;
  PROTOBUF_NODISCARD ::AckResp* release_ackresp();
  ::AckResp* mutable_ackresp();
  void set_allocated_ackresp(::AckResp* ackresp);
  private:
  const ::AckResp& _internal_ackresp() const;
  ::AckResp* _internal_mutable_ackresp();
  public:
  void unsafe_arena_set_allocated_ackresp(
      ::AckResp* ackresp);
  ::AckResp* unsafe_arena_release_ackresp();

  // .NackResp nackresp = 5;
  bool has_nackresp() const;
  private:
  bool _internal_has_nackresp() const;
  public:
  void clear_nackresp();
  const ::NackResp& nackresp() const;
  PROTOBUF_NODISCARD ::NackResp* release_nackresp();
  ::NackResp* mutable_nackresp();
  void set_allocated_nackresp(::NackResp* nackresp);
  private:
  const ::NackResp& _internal_nackresp() const;
  ::NackResp* _internal_mutable_nackresp();
  public:
  void unsafe_arena_set_allocated_nackresp(
      ::NackResp* nackresp);
  ::NackResp* unsafe_arena_release_nackresp();

  // .ErrResp errresp = 6;
  bool has_errresp() const;
  private:
  bool _internal_has_errresp() const;
  public:
  void clear_errresp();
  const ::ErrResp& errresp() const;
  PROTOBUF_NODISCARD ::ErrResp* release_errresp();
  ::ErrResp* mutable_errresp();
  void set_allocated_errresp(::ErrResp* errresp);
  private:
  const ::ErrResp& _internal_errresp() const;
  ::ErrResp* _internal_mutable_errresp();
  public:
  void unsafe_arena_set_allocated_errresp(
      ::ErrResp* errresp);
  ::ErrResp* unsafe_arena_release_errresp();

  // .Suspect suspect = 7;
  bool has_suspect() const;
  private:
  bool _internal_has_suspect() const;
  public:
  void clear_suspect();
  const ::Suspect& suspect() const;
  PROTOBUF_NODISCARD ::Suspect* release_suspect();
  ::Suspect* mutable_suspect();
  void set_allocated_suspect(::Suspect* suspect);
  private:
  const ::Suspect& _internal_suspect() const;
  ::Suspect* _internal_mutable_suspect();
  public:
  void unsafe_arena_set_allocated_suspect(
      ::Suspect* suspect);
  ::Suspect* unsafe_arena_release_suspect();

  // .Alive alive = 8;
  bool has_alive() const;
  private:
  bool _internal_has_alive() const;
  public:
  void clear_alive();
  const ::Alive& alive() const;
  PROTOBUF_NODISCARD ::Alive* release_alive();
  ::Alive* mutable_alive();
  void set_allocated_alive(::Alive* alive);
  private:
  const ::Alive& _internal_alive() const;
  ::Alive* _internal_mutable_alive();
  public:
  void unsafe_arena_set_allocated_alive(
      ::Alive* alive);
  ::Alive* unsafe_arena_release_alive();

  // .Dead dead = 9;
  bool has_dead() const;
  private:
  bool _internal_has_dead() const;
  public:
  void clear_dead();
  const ::Dead& dead() const;
  PROTOBUF_NODISCARD ::Dead* release_dead();
  ::Dead* mutable_dead();
  void set_allocated_dead(::Dead* dead);
  private:
  const ::Dead& _internal_dead() const;
  ::Dead* _internal_mutable_dead();
  public:
  void unsafe_arena_set_allocated_dead(
      ::Dead* dead);
  ::Dead* unsafe_arena_release_dead();

  // .PushPull pushpull = 10;
  bool has_pushpull() const;
  private:
  bool _internal_has_pushpull() const;
  public:
  void clear_pushpull();
  const ::PushPull& pushpull() const;
  PROTOBUF_NODISCARD ::PushPull* release_pushpull();
  ::PushPull* mutable_pushpull();
  void set_allocated_pushpull(::PushPull* pushpull);
  private:
  const ::PushPull& _internal_pushpull() const;
  ::PushPull* _internal_mutable_pushpull();
  public:
  void unsafe_arena_set_allocated_pushpull(
      ::PushPull* pushpull);
  ::PushPull* unsafe_arena_release_pushpull();

  // .User user = 11;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::User& user() const;
  PROTOBUF_NODISCARD ::User* release_user();
  ::User* mutable_user();
  void set_allocated_user(::User* user);
  private:
  const ::User& _internal_user() const;
  ::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::User* user);
  ::User* unsafe_arena_release_user();

  void clear_Body();
  BodyCase Body_case() const;
  // @@protoc_insertion_point(class_scope:MessageData)
 private:
  class _Internal;
  void set_has_ping();
  void set_has_indirectping();
  void set_has_ackresp();
  void set_has_nackresp();
  void set_has_errresp();
  void set_has_suspect();
  void set_has_alive();
  void set_has_dead();
  void set_has_pushpull();
  void set_has_user();

  inline bool has_Body() const;
  inline void clear_has_Body();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int head_;
  union BodyUnion {
    constexpr BodyUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::Ping* ping_;
    ::IndirectPing* indirectping_;
    ::AckResp* ackresp_;
    ::NackResp* nackresp_;
    ::ErrResp* errresp_;
    ::Suspect* suspect_;
    ::Alive* alive_;
    ::Dead* dead_;
    ::PushPull* pushpull_;
    ::User* user_;
  } Body_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  explicit constexpr Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Ping& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kSourceAddrFieldNumber = 3,
    kSourceNodeFieldNumber = 5,
    kSeqNoFieldNumber = 1,
    kSourcePortFieldNumber = 4,
  };
  // string Node = 2;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // string SourceAddr = 3;
  void clear_sourceaddr();
  const std::string& sourceaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceaddr();
  PROTOBUF_NODISCARD std::string* release_sourceaddr();
  void set_allocated_sourceaddr(std::string* sourceaddr);
  private:
  const std::string& _internal_sourceaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceaddr(const std::string& value);
  std::string* _internal_mutable_sourceaddr();
  public:

  // string SourceNode = 5;
  void clear_sourcenode();
  const std::string& sourcenode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcenode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcenode();
  PROTOBUF_NODISCARD std::string* release_sourcenode();
  void set_allocated_sourcenode(std::string* sourcenode);
  private:
  const std::string& _internal_sourcenode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcenode(const std::string& value);
  std::string* _internal_mutable_sourcenode();
  public:

  // uint32 SeqNo = 1;
  void clear_seqno();
  uint32_t seqno() const;
  void set_seqno(uint32_t value);
  private:
  uint32_t _internal_seqno() const;
  void _internal_set_seqno(uint32_t value);
  public:

  // uint32 SourcePort = 4;
  void clear_sourceport();
  uint32_t sourceport() const;
  void set_sourceport(uint32_t value);
  private:
  uint32_t _internal_sourceport() const;
  void _internal_set_sourceport(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceaddr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcenode_;
  uint32_t seqno_;
  uint32_t sourceport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class IndirectPing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IndirectPing) */ {
 public:
  inline IndirectPing() : IndirectPing(nullptr) {}
  ~IndirectPing() override;
  explicit constexpr IndirectPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndirectPing(const IndirectPing& from);
  IndirectPing(IndirectPing&& from) noexcept
    : IndirectPing() {
    *this = ::std::move(from);
  }

  inline IndirectPing& operator=(const IndirectPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndirectPing& operator=(IndirectPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndirectPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndirectPing* internal_default_instance() {
    return reinterpret_cast<const IndirectPing*>(
               &_IndirectPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IndirectPing& a, IndirectPing& b) {
    a.Swap(&b);
  }
  inline void Swap(IndirectPing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndirectPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndirectPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndirectPing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndirectPing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IndirectPing& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndirectPing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IndirectPing";
  }
  protected:
  explicit IndirectPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kTargetAddrFieldNumber = 3,
    kSourceAddrFieldNumber = 6,
    kSourceNodeFieldNumber = 8,
    kSeqNoFieldNumber = 1,
    kTargetPortFieldNumber = 4,
    kNackFieldNumber = 5,
    kSourcePortFieldNumber = 7,
  };
  // string Node = 2;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // string TargetAddr = 3;
  void clear_targetaddr();
  const std::string& targetaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetaddr();
  PROTOBUF_NODISCARD std::string* release_targetaddr();
  void set_allocated_targetaddr(std::string* targetaddr);
  private:
  const std::string& _internal_targetaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetaddr(const std::string& value);
  std::string* _internal_mutable_targetaddr();
  public:

  // string SourceAddr = 6;
  void clear_sourceaddr();
  const std::string& sourceaddr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourceaddr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourceaddr();
  PROTOBUF_NODISCARD std::string* release_sourceaddr();
  void set_allocated_sourceaddr(std::string* sourceaddr);
  private:
  const std::string& _internal_sourceaddr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourceaddr(const std::string& value);
  std::string* _internal_mutable_sourceaddr();
  public:

  // string SourceNode = 8;
  void clear_sourcenode();
  const std::string& sourcenode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sourcenode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sourcenode();
  PROTOBUF_NODISCARD std::string* release_sourcenode();
  void set_allocated_sourcenode(std::string* sourcenode);
  private:
  const std::string& _internal_sourcenode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sourcenode(const std::string& value);
  std::string* _internal_mutable_sourcenode();
  public:

  // uint32 SeqNo = 1;
  void clear_seqno();
  uint32_t seqno() const;
  void set_seqno(uint32_t value);
  private:
  uint32_t _internal_seqno() const;
  void _internal_set_seqno(uint32_t value);
  public:

  // uint32 TargetPort = 4;
  void clear_targetport();
  uint32_t targetport() const;
  void set_targetport(uint32_t value);
  private:
  uint32_t _internal_targetport() const;
  void _internal_set_targetport(uint32_t value);
  public:

  // bool Nack = 5;
  void clear_nack();
  bool nack() const;
  void set_nack(bool value);
  private:
  bool _internal_nack() const;
  void _internal_set_nack(bool value);
  public:

  // uint32 SourcePort = 7;
  void clear_sourceport();
  uint32_t sourceport() const;
  void set_sourceport(uint32_t value);
  private:
  uint32_t _internal_sourceport() const;
  void _internal_set_sourceport(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IndirectPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetaddr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourceaddr_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sourcenode_;
  uint32_t seqno_;
  uint32_t targetport_;
  bool nack_;
  uint32_t sourceport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class AckResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AckResp) */ {
 public:
  inline AckResp() : AckResp(nullptr) {}
  ~AckResp() override;
  explicit constexpr AckResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AckResp(const AckResp& from);
  AckResp(AckResp&& from) noexcept
    : AckResp() {
    *this = ::std::move(from);
  }

  inline AckResp& operator=(const AckResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AckResp& operator=(AckResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AckResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AckResp* internal_default_instance() {
    return reinterpret_cast<const AckResp*>(
               &_AckResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AckResp& a, AckResp& b) {
    a.Swap(&b);
  }
  inline void Swap(AckResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AckResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AckResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AckResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AckResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AckResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AckResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AckResp";
  }
  protected:
  explicit AckResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqNoFieldNumber = 1,
  };
  // uint32 SeqNo = 1;
  void clear_seqno();
  uint32_t seqno() const;
  void set_seqno(uint32_t value);
  private:
  uint32_t _internal_seqno() const;
  void _internal_set_seqno(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AckResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t seqno_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class NackResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:NackResp) */ {
 public:
  inline NackResp() : NackResp(nullptr) {}
  ~NackResp() override;
  explicit constexpr NackResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NackResp(const NackResp& from);
  NackResp(NackResp&& from) noexcept
    : NackResp() {
    *this = ::std::move(from);
  }

  inline NackResp& operator=(const NackResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline NackResp& operator=(NackResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NackResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const NackResp* internal_default_instance() {
    return reinterpret_cast<const NackResp*>(
               &_NackResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NackResp& a, NackResp& b) {
    a.Swap(&b);
  }
  inline void Swap(NackResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NackResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NackResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NackResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NackResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NackResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NackResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "NackResp";
  }
  protected:
  explicit NackResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeqNoFieldNumber = 1,
  };
  // uint32 SeqNo = 1;
  void clear_seqno();
  uint32_t seqno() const;
  void set_seqno(uint32_t value);
  private:
  uint32_t _internal_seqno() const;
  void _internal_set_seqno(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:NackResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t seqno_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class ErrResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ErrResp) */ {
 public:
  inline ErrResp() : ErrResp(nullptr) {}
  ~ErrResp() override;
  explicit constexpr ErrResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrResp(const ErrResp& from);
  ErrResp(ErrResp&& from) noexcept
    : ErrResp() {
    *this = ::std::move(from);
  }

  inline ErrResp& operator=(const ErrResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrResp& operator=(ErrResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrResp* internal_default_instance() {
    return reinterpret_cast<const ErrResp*>(
               &_ErrResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ErrResp& a, ErrResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ErrResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ErrResp";
  }
  protected:
  explicit ErrResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // string Error = 1;
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // @@protoc_insertion_point(class_scope:ErrResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class Suspect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Suspect) */ {
 public:
  inline Suspect() : Suspect(nullptr) {}
  ~Suspect() override;
  explicit constexpr Suspect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Suspect(const Suspect& from);
  Suspect(Suspect&& from) noexcept
    : Suspect() {
    *this = ::std::move(from);
  }

  inline Suspect& operator=(const Suspect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Suspect& operator=(Suspect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Suspect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Suspect* internal_default_instance() {
    return reinterpret_cast<const Suspect*>(
               &_Suspect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Suspect& a, Suspect& b) {
    a.Swap(&b);
  }
  inline void Swap(Suspect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Suspect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Suspect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Suspect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Suspect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Suspect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Suspect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Suspect";
  }
  protected:
  explicit Suspect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kFromFieldNumber = 3,
    kIncarnationFieldNumber = 1,
  };
  // string Node = 2;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // string From = 3;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // uint32 Incarnation = 1;
  void clear_incarnation();
  uint32_t incarnation() const;
  void set_incarnation(uint32_t value);
  private:
  uint32_t _internal_incarnation() const;
  void _internal_set_incarnation(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Suspect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  uint32_t incarnation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class Alive final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Alive) */ {
 public:
  inline Alive() : Alive(nullptr) {}
  ~Alive() override;
  explicit constexpr Alive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Alive(const Alive& from);
  Alive(Alive&& from) noexcept
    : Alive() {
    *this = ::std::move(from);
  }

  inline Alive& operator=(const Alive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Alive& operator=(Alive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Alive& default_instance() {
    return *internal_default_instance();
  }
  static inline const Alive* internal_default_instance() {
    return reinterpret_cast<const Alive*>(
               &_Alive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Alive& a, Alive& b) {
    a.Swap(&b);
  }
  inline void Swap(Alive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Alive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Alive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Alive>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Alive& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Alive& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Alive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Alive";
  }
  protected:
  explicit Alive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kAddrFieldNumber = 3,
    kIncarnationFieldNumber = 1,
    kPortFieldNumber = 4,
  };
  // string Node = 2;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // string Addr = 3;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // uint32 Incarnation = 1;
  void clear_incarnation();
  uint32_t incarnation() const;
  void set_incarnation(uint32_t value);
  private:
  uint32_t _internal_incarnation() const;
  void _internal_set_incarnation(uint32_t value);
  public:

  // uint32 Port = 4;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Alive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  uint32_t incarnation_;
  uint32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class Dead final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Dead) */ {
 public:
  inline Dead() : Dead(nullptr) {}
  ~Dead() override;
  explicit constexpr Dead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dead(const Dead& from);
  Dead(Dead&& from) noexcept
    : Dead() {
    *this = ::std::move(from);
  }

  inline Dead& operator=(const Dead& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dead& operator=(Dead&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dead& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dead* internal_default_instance() {
    return reinterpret_cast<const Dead*>(
               &_Dead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Dead& a, Dead& b) {
    a.Swap(&b);
  }
  inline void Swap(Dead* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dead* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dead>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dead& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Dead& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dead* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Dead";
  }
  protected:
  explicit Dead(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 2,
    kFromFieldNumber = 3,
    kIncarnationFieldNumber = 1,
  };
  // string Node = 2;
  void clear_node();
  const std::string& node() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* node);
  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(const std::string& value);
  std::string* _internal_mutable_node();
  public:

  // string From = 3;
  void clear_from();
  const std::string& from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_from();
  PROTOBUF_NODISCARD std::string* release_from();
  void set_allocated_from(std::string* from);
  private:
  const std::string& _internal_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
  std::string* _internal_mutable_from();
  public:

  // uint32 Incarnation = 1;
  void clear_incarnation();
  uint32_t incarnation() const;
  void set_incarnation(uint32_t value);
  private:
  uint32_t _internal_incarnation() const;
  void _internal_set_incarnation(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Dead)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
  uint32_t incarnation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class PushPull final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PushPull) */ {
 public:
  inline PushPull() : PushPull(nullptr) {}
  ~PushPull() override;
  explicit constexpr PushPull(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushPull(const PushPull& from);
  PushPull(PushPull&& from) noexcept
    : PushPull() {
    *this = ::std::move(from);
  }

  inline PushPull& operator=(const PushPull& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushPull& operator=(PushPull&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushPull& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushPull* internal_default_instance() {
    return reinterpret_cast<const PushPull*>(
               &_PushPull_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PushPull& a, PushPull& b) {
    a.Swap(&b);
  }
  inline void Swap(PushPull* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushPull* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushPull* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushPull>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushPull& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushPull& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushPull* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PushPull";
  }
  protected:
  explicit PushPull(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 2,
    kJoinFieldNumber = 1,
  };
  // repeated .PushNodeState States = 2;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  ::PushNodeState* mutable_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PushNodeState >*
      mutable_states();
  private:
  const ::PushNodeState& _internal_states(int index) const;
  ::PushNodeState* _internal_add_states();
  public:
  const ::PushNodeState& states(int index) const;
  ::PushNodeState* add_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PushNodeState >&
      states() const;

  // bool Join = 1;
  void clear_join();
  bool join() const;
  void set_join(bool value);
  private:
  bool _internal_join() const;
  void _internal_set_join(bool value);
  public:

  // @@protoc_insertion_point(class_scope:PushPull)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PushNodeState > states_;
  bool join_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class PushNodeState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PushNodeState) */ {
 public:
  inline PushNodeState() : PushNodeState(nullptr) {}
  ~PushNodeState() override;
  explicit constexpr PushNodeState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PushNodeState(const PushNodeState& from);
  PushNodeState(PushNodeState&& from) noexcept
    : PushNodeState() {
    *this = ::std::move(from);
  }

  inline PushNodeState& operator=(const PushNodeState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushNodeState& operator=(PushNodeState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushNodeState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushNodeState* internal_default_instance() {
    return reinterpret_cast<const PushNodeState*>(
               &_PushNodeState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(PushNodeState& a, PushNodeState& b) {
    a.Swap(&b);
  }
  inline void Swap(PushNodeState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushNodeState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushNodeState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushNodeState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PushNodeState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PushNodeState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushNodeState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PushNodeState";
  }
  protected:
  explicit PushNodeState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PushNodeState_NodeStateType NodeStateType;
  static constexpr NodeStateType StateAlive =
    PushNodeState_NodeStateType_StateAlive;
  static constexpr NodeStateType StateSuspect =
    PushNodeState_NodeStateType_StateSuspect;
  static constexpr NodeStateType StateDead =
    PushNodeState_NodeStateType_StateDead;
  static constexpr NodeStateType StateLeft =
    PushNodeState_NodeStateType_StateLeft;
  static inline bool NodeStateType_IsValid(int value) {
    return PushNodeState_NodeStateType_IsValid(value);
  }
  static constexpr NodeStateType NodeStateType_MIN =
    PushNodeState_NodeStateType_NodeStateType_MIN;
  static constexpr NodeStateType NodeStateType_MAX =
    PushNodeState_NodeStateType_NodeStateType_MAX;
  static constexpr int NodeStateType_ARRAYSIZE =
    PushNodeState_NodeStateType_NodeStateType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NodeStateType_descriptor() {
    return PushNodeState_NodeStateType_descriptor();
  }
  template<typename T>
  static inline const std::string& NodeStateType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NodeStateType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NodeStateType_Name.");
    return PushNodeState_NodeStateType_Name(enum_t_value);
  }
  static inline bool NodeStateType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NodeStateType* value) {
    return PushNodeState_NodeStateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kAddrFieldNumber = 2,
    kPortFieldNumber = 3,
    kIncarnationFieldNumber = 4,
    kStateFieldNumber = 5,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Addr = 2;
  void clear_addr();
  const std::string& addr() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_addr(ArgT0&& arg0, ArgT... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* addr);
  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(const std::string& value);
  std::string* _internal_mutable_addr();
  public:

  // uint32 Port = 3;
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // uint32 Incarnation = 4;
  void clear_incarnation();
  uint32_t incarnation() const;
  void set_incarnation(uint32_t value);
  private:
  uint32_t _internal_incarnation() const;
  void _internal_set_incarnation(uint32_t value);
  public:

  // .PushNodeState.NodeStateType State = 5;
  void clear_state();
  ::PushNodeState_NodeStateType state() const;
  void set_state(::PushNodeState_NodeStateType value);
  private:
  ::PushNodeState_NodeStateType _internal_state() const;
  void _internal_set_state(::PushNodeState_NodeStateType value);
  public:

  // @@protoc_insertion_point(class_scope:PushNodeState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr addr_;
  uint32_t port_;
  uint32_t incarnation_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit constexpr User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 1,
  };
  // string Msg = 1;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // @@protoc_insertion_point(class_scope:User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msgtype_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MessageData

// .MessageData.MessageType Head = 1;
inline void MessageData::clear_head() {
  head_ = 0;
}
inline ::MessageData_MessageType MessageData::_internal_head() const {
  return static_cast< ::MessageData_MessageType >(head_);
}
inline ::MessageData_MessageType MessageData::head() const {
  // @@protoc_insertion_point(field_get:MessageData.Head)
  return _internal_head();
}
inline void MessageData::_internal_set_head(::MessageData_MessageType value) {
  
  head_ = value;
}
inline void MessageData::set_head(::MessageData_MessageType value) {
  _internal_set_head(value);
  // @@protoc_insertion_point(field_set:MessageData.Head)
}

// .Ping ping = 2;
inline bool MessageData::_internal_has_ping() const {
  return Body_case() == kPing;
}
inline bool MessageData::has_ping() const {
  return _internal_has_ping();
}
inline void MessageData::set_has_ping() {
  _oneof_case_[0] = kPing;
}
inline void MessageData::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.ping_;
    }
    clear_has_Body();
  }
}
inline ::Ping* MessageData::release_ping() {
  // @@protoc_insertion_point(field_release:MessageData.ping)
  if (_internal_has_ping()) {
    clear_has_Body();
      ::Ping* temp = Body_.ping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Ping& MessageData::_internal_ping() const {
  return _internal_has_ping()
      ? *Body_.ping_
      : reinterpret_cast< ::Ping&>(::_Ping_default_instance_);
}
inline const ::Ping& MessageData::ping() const {
  // @@protoc_insertion_point(field_get:MessageData.ping)
  return _internal_ping();
}
inline ::Ping* MessageData::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.ping)
  if (_internal_has_ping()) {
    clear_has_Body();
    ::Ping* temp = Body_.ping_;
    Body_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_ping(::Ping* ping) {
  clear_Body();
  if (ping) {
    set_has_ping();
    Body_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.ping)
}
inline ::Ping* MessageData::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_Body();
    set_has_ping();
    Body_.ping_ = CreateMaybeMessage< ::Ping >(GetArenaForAllocation());
  }
  return Body_.ping_;
}
inline ::Ping* MessageData::mutable_ping() {
  ::Ping* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:MessageData.ping)
  return _msg;
}

// .IndirectPing indirectping = 3;
inline bool MessageData::_internal_has_indirectping() const {
  return Body_case() == kIndirectping;
}
inline bool MessageData::has_indirectping() const {
  return _internal_has_indirectping();
}
inline void MessageData::set_has_indirectping() {
  _oneof_case_[0] = kIndirectping;
}
inline void MessageData::clear_indirectping() {
  if (_internal_has_indirectping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.indirectping_;
    }
    clear_has_Body();
  }
}
inline ::IndirectPing* MessageData::release_indirectping() {
  // @@protoc_insertion_point(field_release:MessageData.indirectping)
  if (_internal_has_indirectping()) {
    clear_has_Body();
      ::IndirectPing* temp = Body_.indirectping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.indirectping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IndirectPing& MessageData::_internal_indirectping() const {
  return _internal_has_indirectping()
      ? *Body_.indirectping_
      : reinterpret_cast< ::IndirectPing&>(::_IndirectPing_default_instance_);
}
inline const ::IndirectPing& MessageData::indirectping() const {
  // @@protoc_insertion_point(field_get:MessageData.indirectping)
  return _internal_indirectping();
}
inline ::IndirectPing* MessageData::unsafe_arena_release_indirectping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.indirectping)
  if (_internal_has_indirectping()) {
    clear_has_Body();
    ::IndirectPing* temp = Body_.indirectping_;
    Body_.indirectping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_indirectping(::IndirectPing* indirectping) {
  clear_Body();
  if (indirectping) {
    set_has_indirectping();
    Body_.indirectping_ = indirectping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.indirectping)
}
inline ::IndirectPing* MessageData::_internal_mutable_indirectping() {
  if (!_internal_has_indirectping()) {
    clear_Body();
    set_has_indirectping();
    Body_.indirectping_ = CreateMaybeMessage< ::IndirectPing >(GetArenaForAllocation());
  }
  return Body_.indirectping_;
}
inline ::IndirectPing* MessageData::mutable_indirectping() {
  ::IndirectPing* _msg = _internal_mutable_indirectping();
  // @@protoc_insertion_point(field_mutable:MessageData.indirectping)
  return _msg;
}

// .AckResp ackresp = 4;
inline bool MessageData::_internal_has_ackresp() const {
  return Body_case() == kAckresp;
}
inline bool MessageData::has_ackresp() const {
  return _internal_has_ackresp();
}
inline void MessageData::set_has_ackresp() {
  _oneof_case_[0] = kAckresp;
}
inline void MessageData::clear_ackresp() {
  if (_internal_has_ackresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.ackresp_;
    }
    clear_has_Body();
  }
}
inline ::AckResp* MessageData::release_ackresp() {
  // @@protoc_insertion_point(field_release:MessageData.ackresp)
  if (_internal_has_ackresp()) {
    clear_has_Body();
      ::AckResp* temp = Body_.ackresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.ackresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::AckResp& MessageData::_internal_ackresp() const {
  return _internal_has_ackresp()
      ? *Body_.ackresp_
      : reinterpret_cast< ::AckResp&>(::_AckResp_default_instance_);
}
inline const ::AckResp& MessageData::ackresp() const {
  // @@protoc_insertion_point(field_get:MessageData.ackresp)
  return _internal_ackresp();
}
inline ::AckResp* MessageData::unsafe_arena_release_ackresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.ackresp)
  if (_internal_has_ackresp()) {
    clear_has_Body();
    ::AckResp* temp = Body_.ackresp_;
    Body_.ackresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_ackresp(::AckResp* ackresp) {
  clear_Body();
  if (ackresp) {
    set_has_ackresp();
    Body_.ackresp_ = ackresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.ackresp)
}
inline ::AckResp* MessageData::_internal_mutable_ackresp() {
  if (!_internal_has_ackresp()) {
    clear_Body();
    set_has_ackresp();
    Body_.ackresp_ = CreateMaybeMessage< ::AckResp >(GetArenaForAllocation());
  }
  return Body_.ackresp_;
}
inline ::AckResp* MessageData::mutable_ackresp() {
  ::AckResp* _msg = _internal_mutable_ackresp();
  // @@protoc_insertion_point(field_mutable:MessageData.ackresp)
  return _msg;
}

// .NackResp nackresp = 5;
inline bool MessageData::_internal_has_nackresp() const {
  return Body_case() == kNackresp;
}
inline bool MessageData::has_nackresp() const {
  return _internal_has_nackresp();
}
inline void MessageData::set_has_nackresp() {
  _oneof_case_[0] = kNackresp;
}
inline void MessageData::clear_nackresp() {
  if (_internal_has_nackresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.nackresp_;
    }
    clear_has_Body();
  }
}
inline ::NackResp* MessageData::release_nackresp() {
  // @@protoc_insertion_point(field_release:MessageData.nackresp)
  if (_internal_has_nackresp()) {
    clear_has_Body();
      ::NackResp* temp = Body_.nackresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.nackresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::NackResp& MessageData::_internal_nackresp() const {
  return _internal_has_nackresp()
      ? *Body_.nackresp_
      : reinterpret_cast< ::NackResp&>(::_NackResp_default_instance_);
}
inline const ::NackResp& MessageData::nackresp() const {
  // @@protoc_insertion_point(field_get:MessageData.nackresp)
  return _internal_nackresp();
}
inline ::NackResp* MessageData::unsafe_arena_release_nackresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.nackresp)
  if (_internal_has_nackresp()) {
    clear_has_Body();
    ::NackResp* temp = Body_.nackresp_;
    Body_.nackresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_nackresp(::NackResp* nackresp) {
  clear_Body();
  if (nackresp) {
    set_has_nackresp();
    Body_.nackresp_ = nackresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.nackresp)
}
inline ::NackResp* MessageData::_internal_mutable_nackresp() {
  if (!_internal_has_nackresp()) {
    clear_Body();
    set_has_nackresp();
    Body_.nackresp_ = CreateMaybeMessage< ::NackResp >(GetArenaForAllocation());
  }
  return Body_.nackresp_;
}
inline ::NackResp* MessageData::mutable_nackresp() {
  ::NackResp* _msg = _internal_mutable_nackresp();
  // @@protoc_insertion_point(field_mutable:MessageData.nackresp)
  return _msg;
}

// .ErrResp errresp = 6;
inline bool MessageData::_internal_has_errresp() const {
  return Body_case() == kErrresp;
}
inline bool MessageData::has_errresp() const {
  return _internal_has_errresp();
}
inline void MessageData::set_has_errresp() {
  _oneof_case_[0] = kErrresp;
}
inline void MessageData::clear_errresp() {
  if (_internal_has_errresp()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.errresp_;
    }
    clear_has_Body();
  }
}
inline ::ErrResp* MessageData::release_errresp() {
  // @@protoc_insertion_point(field_release:MessageData.errresp)
  if (_internal_has_errresp()) {
    clear_has_Body();
      ::ErrResp* temp = Body_.errresp_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.errresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ErrResp& MessageData::_internal_errresp() const {
  return _internal_has_errresp()
      ? *Body_.errresp_
      : reinterpret_cast< ::ErrResp&>(::_ErrResp_default_instance_);
}
inline const ::ErrResp& MessageData::errresp() const {
  // @@protoc_insertion_point(field_get:MessageData.errresp)
  return _internal_errresp();
}
inline ::ErrResp* MessageData::unsafe_arena_release_errresp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.errresp)
  if (_internal_has_errresp()) {
    clear_has_Body();
    ::ErrResp* temp = Body_.errresp_;
    Body_.errresp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_errresp(::ErrResp* errresp) {
  clear_Body();
  if (errresp) {
    set_has_errresp();
    Body_.errresp_ = errresp;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.errresp)
}
inline ::ErrResp* MessageData::_internal_mutable_errresp() {
  if (!_internal_has_errresp()) {
    clear_Body();
    set_has_errresp();
    Body_.errresp_ = CreateMaybeMessage< ::ErrResp >(GetArenaForAllocation());
  }
  return Body_.errresp_;
}
inline ::ErrResp* MessageData::mutable_errresp() {
  ::ErrResp* _msg = _internal_mutable_errresp();
  // @@protoc_insertion_point(field_mutable:MessageData.errresp)
  return _msg;
}

// .Suspect suspect = 7;
inline bool MessageData::_internal_has_suspect() const {
  return Body_case() == kSuspect;
}
inline bool MessageData::has_suspect() const {
  return _internal_has_suspect();
}
inline void MessageData::set_has_suspect() {
  _oneof_case_[0] = kSuspect;
}
inline void MessageData::clear_suspect() {
  if (_internal_has_suspect()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.suspect_;
    }
    clear_has_Body();
  }
}
inline ::Suspect* MessageData::release_suspect() {
  // @@protoc_insertion_point(field_release:MessageData.suspect)
  if (_internal_has_suspect()) {
    clear_has_Body();
      ::Suspect* temp = Body_.suspect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.suspect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Suspect& MessageData::_internal_suspect() const {
  return _internal_has_suspect()
      ? *Body_.suspect_
      : reinterpret_cast< ::Suspect&>(::_Suspect_default_instance_);
}
inline const ::Suspect& MessageData::suspect() const {
  // @@protoc_insertion_point(field_get:MessageData.suspect)
  return _internal_suspect();
}
inline ::Suspect* MessageData::unsafe_arena_release_suspect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.suspect)
  if (_internal_has_suspect()) {
    clear_has_Body();
    ::Suspect* temp = Body_.suspect_;
    Body_.suspect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_suspect(::Suspect* suspect) {
  clear_Body();
  if (suspect) {
    set_has_suspect();
    Body_.suspect_ = suspect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.suspect)
}
inline ::Suspect* MessageData::_internal_mutable_suspect() {
  if (!_internal_has_suspect()) {
    clear_Body();
    set_has_suspect();
    Body_.suspect_ = CreateMaybeMessage< ::Suspect >(GetArenaForAllocation());
  }
  return Body_.suspect_;
}
inline ::Suspect* MessageData::mutable_suspect() {
  ::Suspect* _msg = _internal_mutable_suspect();
  // @@protoc_insertion_point(field_mutable:MessageData.suspect)
  return _msg;
}

// .Alive alive = 8;
inline bool MessageData::_internal_has_alive() const {
  return Body_case() == kAlive;
}
inline bool MessageData::has_alive() const {
  return _internal_has_alive();
}
inline void MessageData::set_has_alive() {
  _oneof_case_[0] = kAlive;
}
inline void MessageData::clear_alive() {
  if (_internal_has_alive()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.alive_;
    }
    clear_has_Body();
  }
}
inline ::Alive* MessageData::release_alive() {
  // @@protoc_insertion_point(field_release:MessageData.alive)
  if (_internal_has_alive()) {
    clear_has_Body();
      ::Alive* temp = Body_.alive_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.alive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Alive& MessageData::_internal_alive() const {
  return _internal_has_alive()
      ? *Body_.alive_
      : reinterpret_cast< ::Alive&>(::_Alive_default_instance_);
}
inline const ::Alive& MessageData::alive() const {
  // @@protoc_insertion_point(field_get:MessageData.alive)
  return _internal_alive();
}
inline ::Alive* MessageData::unsafe_arena_release_alive() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.alive)
  if (_internal_has_alive()) {
    clear_has_Body();
    ::Alive* temp = Body_.alive_;
    Body_.alive_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_alive(::Alive* alive) {
  clear_Body();
  if (alive) {
    set_has_alive();
    Body_.alive_ = alive;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.alive)
}
inline ::Alive* MessageData::_internal_mutable_alive() {
  if (!_internal_has_alive()) {
    clear_Body();
    set_has_alive();
    Body_.alive_ = CreateMaybeMessage< ::Alive >(GetArenaForAllocation());
  }
  return Body_.alive_;
}
inline ::Alive* MessageData::mutable_alive() {
  ::Alive* _msg = _internal_mutable_alive();
  // @@protoc_insertion_point(field_mutable:MessageData.alive)
  return _msg;
}

// .Dead dead = 9;
inline bool MessageData::_internal_has_dead() const {
  return Body_case() == kDead;
}
inline bool MessageData::has_dead() const {
  return _internal_has_dead();
}
inline void MessageData::set_has_dead() {
  _oneof_case_[0] = kDead;
}
inline void MessageData::clear_dead() {
  if (_internal_has_dead()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.dead_;
    }
    clear_has_Body();
  }
}
inline ::Dead* MessageData::release_dead() {
  // @@protoc_insertion_point(field_release:MessageData.dead)
  if (_internal_has_dead()) {
    clear_has_Body();
      ::Dead* temp = Body_.dead_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.dead_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Dead& MessageData::_internal_dead() const {
  return _internal_has_dead()
      ? *Body_.dead_
      : reinterpret_cast< ::Dead&>(::_Dead_default_instance_);
}
inline const ::Dead& MessageData::dead() const {
  // @@protoc_insertion_point(field_get:MessageData.dead)
  return _internal_dead();
}
inline ::Dead* MessageData::unsafe_arena_release_dead() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.dead)
  if (_internal_has_dead()) {
    clear_has_Body();
    ::Dead* temp = Body_.dead_;
    Body_.dead_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_dead(::Dead* dead) {
  clear_Body();
  if (dead) {
    set_has_dead();
    Body_.dead_ = dead;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.dead)
}
inline ::Dead* MessageData::_internal_mutable_dead() {
  if (!_internal_has_dead()) {
    clear_Body();
    set_has_dead();
    Body_.dead_ = CreateMaybeMessage< ::Dead >(GetArenaForAllocation());
  }
  return Body_.dead_;
}
inline ::Dead* MessageData::mutable_dead() {
  ::Dead* _msg = _internal_mutable_dead();
  // @@protoc_insertion_point(field_mutable:MessageData.dead)
  return _msg;
}

// .PushPull pushpull = 10;
inline bool MessageData::_internal_has_pushpull() const {
  return Body_case() == kPushpull;
}
inline bool MessageData::has_pushpull() const {
  return _internal_has_pushpull();
}
inline void MessageData::set_has_pushpull() {
  _oneof_case_[0] = kPushpull;
}
inline void MessageData::clear_pushpull() {
  if (_internal_has_pushpull()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.pushpull_;
    }
    clear_has_Body();
  }
}
inline ::PushPull* MessageData::release_pushpull() {
  // @@protoc_insertion_point(field_release:MessageData.pushpull)
  if (_internal_has_pushpull()) {
    clear_has_Body();
      ::PushPull* temp = Body_.pushpull_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.pushpull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PushPull& MessageData::_internal_pushpull() const {
  return _internal_has_pushpull()
      ? *Body_.pushpull_
      : reinterpret_cast< ::PushPull&>(::_PushPull_default_instance_);
}
inline const ::PushPull& MessageData::pushpull() const {
  // @@protoc_insertion_point(field_get:MessageData.pushpull)
  return _internal_pushpull();
}
inline ::PushPull* MessageData::unsafe_arena_release_pushpull() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.pushpull)
  if (_internal_has_pushpull()) {
    clear_has_Body();
    ::PushPull* temp = Body_.pushpull_;
    Body_.pushpull_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_pushpull(::PushPull* pushpull) {
  clear_Body();
  if (pushpull) {
    set_has_pushpull();
    Body_.pushpull_ = pushpull;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.pushpull)
}
inline ::PushPull* MessageData::_internal_mutable_pushpull() {
  if (!_internal_has_pushpull()) {
    clear_Body();
    set_has_pushpull();
    Body_.pushpull_ = CreateMaybeMessage< ::PushPull >(GetArenaForAllocation());
  }
  return Body_.pushpull_;
}
inline ::PushPull* MessageData::mutable_pushpull() {
  ::PushPull* _msg = _internal_mutable_pushpull();
  // @@protoc_insertion_point(field_mutable:MessageData.pushpull)
  return _msg;
}

// .User user = 11;
inline bool MessageData::_internal_has_user() const {
  return Body_case() == kUser;
}
inline bool MessageData::has_user() const {
  return _internal_has_user();
}
inline void MessageData::set_has_user() {
  _oneof_case_[0] = kUser;
}
inline void MessageData::clear_user() {
  if (_internal_has_user()) {
    if (GetArenaForAllocation() == nullptr) {
      delete Body_.user_;
    }
    clear_has_Body();
  }
}
inline ::User* MessageData::release_user() {
  // @@protoc_insertion_point(field_release:MessageData.user)
  if (_internal_has_user()) {
    clear_has_Body();
      ::User* temp = Body_.user_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Body_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::User& MessageData::_internal_user() const {
  return _internal_has_user()
      ? *Body_.user_
      : reinterpret_cast< ::User&>(::_User_default_instance_);
}
inline const ::User& MessageData::user() const {
  // @@protoc_insertion_point(field_get:MessageData.user)
  return _internal_user();
}
inline ::User* MessageData::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_unsafe_arena_release:MessageData.user)
  if (_internal_has_user()) {
    clear_has_Body();
    ::User* temp = Body_.user_;
    Body_.user_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageData::unsafe_arena_set_allocated_user(::User* user) {
  clear_Body();
  if (user) {
    set_has_user();
    Body_.user_ = user;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:MessageData.user)
}
inline ::User* MessageData::_internal_mutable_user() {
  if (!_internal_has_user()) {
    clear_Body();
    set_has_user();
    Body_.user_ = CreateMaybeMessage< ::User >(GetArenaForAllocation());
  }
  return Body_.user_;
}
inline ::User* MessageData::mutable_user() {
  ::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:MessageData.user)
  return _msg;
}

inline bool MessageData::has_Body() const {
  return Body_case() != BODY_NOT_SET;
}
inline void MessageData::clear_has_Body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline MessageData::BodyCase MessageData::Body_case() const {
  return MessageData::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ping

// uint32 SeqNo = 1;
inline void Ping::clear_seqno() {
  seqno_ = 0u;
}
inline uint32_t Ping::_internal_seqno() const {
  return seqno_;
}
inline uint32_t Ping::seqno() const {
  // @@protoc_insertion_point(field_get:Ping.SeqNo)
  return _internal_seqno();
}
inline void Ping::_internal_set_seqno(uint32_t value) {
  
  seqno_ = value;
}
inline void Ping::set_seqno(uint32_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:Ping.SeqNo)
}

// string Node = 2;
inline void Ping::clear_node() {
  node_.ClearToEmpty();
}
inline const std::string& Ping::node() const {
  // @@protoc_insertion_point(field_get:Ping.Node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_node(ArgT0&& arg0, ArgT... args) {
 
 node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Ping.Node)
}
inline std::string* Ping::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:Ping.Node)
  return _s;
}
inline const std::string& Ping::_internal_node() const {
  return node_.Get();
}
inline void Ping::_internal_set_node(const std::string& value) {
  
  node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_node() {
  
  return node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Ping::release_node() {
  // @@protoc_insertion_point(field_release:Ping.Node)
  return node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Ping::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Ping.Node)
}

// string SourceAddr = 3;
inline void Ping::clear_sourceaddr() {
  sourceaddr_.ClearToEmpty();
}
inline const std::string& Ping::sourceaddr() const {
  // @@protoc_insertion_point(field_get:Ping.SourceAddr)
  return _internal_sourceaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_sourceaddr(ArgT0&& arg0, ArgT... args) {
 
 sourceaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Ping.SourceAddr)
}
inline std::string* Ping::mutable_sourceaddr() {
  std::string* _s = _internal_mutable_sourceaddr();
  // @@protoc_insertion_point(field_mutable:Ping.SourceAddr)
  return _s;
}
inline const std::string& Ping::_internal_sourceaddr() const {
  return sourceaddr_.Get();
}
inline void Ping::_internal_set_sourceaddr(const std::string& value) {
  
  sourceaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_sourceaddr() {
  
  return sourceaddr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Ping::release_sourceaddr() {
  // @@protoc_insertion_point(field_release:Ping.SourceAddr)
  return sourceaddr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Ping::set_allocated_sourceaddr(std::string* sourceaddr) {
  if (sourceaddr != nullptr) {
    
  } else {
    
  }
  sourceaddr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourceaddr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceaddr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sourceaddr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Ping.SourceAddr)
}

// uint32 SourcePort = 4;
inline void Ping::clear_sourceport() {
  sourceport_ = 0u;
}
inline uint32_t Ping::_internal_sourceport() const {
  return sourceport_;
}
inline uint32_t Ping::sourceport() const {
  // @@protoc_insertion_point(field_get:Ping.SourcePort)
  return _internal_sourceport();
}
inline void Ping::_internal_set_sourceport(uint32_t value) {
  
  sourceport_ = value;
}
inline void Ping::set_sourceport(uint32_t value) {
  _internal_set_sourceport(value);
  // @@protoc_insertion_point(field_set:Ping.SourcePort)
}

// string SourceNode = 5;
inline void Ping::clear_sourcenode() {
  sourcenode_.ClearToEmpty();
}
inline const std::string& Ping::sourcenode() const {
  // @@protoc_insertion_point(field_get:Ping.SourceNode)
  return _internal_sourcenode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Ping::set_sourcenode(ArgT0&& arg0, ArgT... args) {
 
 sourcenode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Ping.SourceNode)
}
inline std::string* Ping::mutable_sourcenode() {
  std::string* _s = _internal_mutable_sourcenode();
  // @@protoc_insertion_point(field_mutable:Ping.SourceNode)
  return _s;
}
inline const std::string& Ping::_internal_sourcenode() const {
  return sourcenode_.Get();
}
inline void Ping::_internal_set_sourcenode(const std::string& value) {
  
  sourcenode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Ping::_internal_mutable_sourcenode() {
  
  return sourcenode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Ping::release_sourcenode() {
  // @@protoc_insertion_point(field_release:Ping.SourceNode)
  return sourcenode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Ping::set_allocated_sourcenode(std::string* sourcenode) {
  if (sourcenode != nullptr) {
    
  } else {
    
  }
  sourcenode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcenode,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcenode_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sourcenode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Ping.SourceNode)
}

// -------------------------------------------------------------------

// IndirectPing

// uint32 SeqNo = 1;
inline void IndirectPing::clear_seqno() {
  seqno_ = 0u;
}
inline uint32_t IndirectPing::_internal_seqno() const {
  return seqno_;
}
inline uint32_t IndirectPing::seqno() const {
  // @@protoc_insertion_point(field_get:IndirectPing.SeqNo)
  return _internal_seqno();
}
inline void IndirectPing::_internal_set_seqno(uint32_t value) {
  
  seqno_ = value;
}
inline void IndirectPing::set_seqno(uint32_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:IndirectPing.SeqNo)
}

// string Node = 2;
inline void IndirectPing::clear_node() {
  node_.ClearToEmpty();
}
inline const std::string& IndirectPing::node() const {
  // @@protoc_insertion_point(field_get:IndirectPing.Node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndirectPing::set_node(ArgT0&& arg0, ArgT... args) {
 
 node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndirectPing.Node)
}
inline std::string* IndirectPing::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:IndirectPing.Node)
  return _s;
}
inline const std::string& IndirectPing::_internal_node() const {
  return node_.Get();
}
inline void IndirectPing::_internal_set_node(const std::string& value) {
  
  node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IndirectPing::_internal_mutable_node() {
  
  return node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IndirectPing::release_node() {
  // @@protoc_insertion_point(field_release:IndirectPing.Node)
  return node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IndirectPing::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndirectPing.Node)
}

// string TargetAddr = 3;
inline void IndirectPing::clear_targetaddr() {
  targetaddr_.ClearToEmpty();
}
inline const std::string& IndirectPing::targetaddr() const {
  // @@protoc_insertion_point(field_get:IndirectPing.TargetAddr)
  return _internal_targetaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndirectPing::set_targetaddr(ArgT0&& arg0, ArgT... args) {
 
 targetaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndirectPing.TargetAddr)
}
inline std::string* IndirectPing::mutable_targetaddr() {
  std::string* _s = _internal_mutable_targetaddr();
  // @@protoc_insertion_point(field_mutable:IndirectPing.TargetAddr)
  return _s;
}
inline const std::string& IndirectPing::_internal_targetaddr() const {
  return targetaddr_.Get();
}
inline void IndirectPing::_internal_set_targetaddr(const std::string& value) {
  
  targetaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IndirectPing::_internal_mutable_targetaddr() {
  
  return targetaddr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IndirectPing::release_targetaddr() {
  // @@protoc_insertion_point(field_release:IndirectPing.TargetAddr)
  return targetaddr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IndirectPing::set_allocated_targetaddr(std::string* targetaddr) {
  if (targetaddr != nullptr) {
    
  } else {
    
  }
  targetaddr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), targetaddr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (targetaddr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    targetaddr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndirectPing.TargetAddr)
}

// uint32 TargetPort = 4;
inline void IndirectPing::clear_targetport() {
  targetport_ = 0u;
}
inline uint32_t IndirectPing::_internal_targetport() const {
  return targetport_;
}
inline uint32_t IndirectPing::targetport() const {
  // @@protoc_insertion_point(field_get:IndirectPing.TargetPort)
  return _internal_targetport();
}
inline void IndirectPing::_internal_set_targetport(uint32_t value) {
  
  targetport_ = value;
}
inline void IndirectPing::set_targetport(uint32_t value) {
  _internal_set_targetport(value);
  // @@protoc_insertion_point(field_set:IndirectPing.TargetPort)
}

// bool Nack = 5;
inline void IndirectPing::clear_nack() {
  nack_ = false;
}
inline bool IndirectPing::_internal_nack() const {
  return nack_;
}
inline bool IndirectPing::nack() const {
  // @@protoc_insertion_point(field_get:IndirectPing.Nack)
  return _internal_nack();
}
inline void IndirectPing::_internal_set_nack(bool value) {
  
  nack_ = value;
}
inline void IndirectPing::set_nack(bool value) {
  _internal_set_nack(value);
  // @@protoc_insertion_point(field_set:IndirectPing.Nack)
}

// string SourceAddr = 6;
inline void IndirectPing::clear_sourceaddr() {
  sourceaddr_.ClearToEmpty();
}
inline const std::string& IndirectPing::sourceaddr() const {
  // @@protoc_insertion_point(field_get:IndirectPing.SourceAddr)
  return _internal_sourceaddr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndirectPing::set_sourceaddr(ArgT0&& arg0, ArgT... args) {
 
 sourceaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndirectPing.SourceAddr)
}
inline std::string* IndirectPing::mutable_sourceaddr() {
  std::string* _s = _internal_mutable_sourceaddr();
  // @@protoc_insertion_point(field_mutable:IndirectPing.SourceAddr)
  return _s;
}
inline const std::string& IndirectPing::_internal_sourceaddr() const {
  return sourceaddr_.Get();
}
inline void IndirectPing::_internal_set_sourceaddr(const std::string& value) {
  
  sourceaddr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IndirectPing::_internal_mutable_sourceaddr() {
  
  return sourceaddr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IndirectPing::release_sourceaddr() {
  // @@protoc_insertion_point(field_release:IndirectPing.SourceAddr)
  return sourceaddr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IndirectPing::set_allocated_sourceaddr(std::string* sourceaddr) {
  if (sourceaddr != nullptr) {
    
  } else {
    
  }
  sourceaddr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourceaddr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourceaddr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sourceaddr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndirectPing.SourceAddr)
}

// uint32 SourcePort = 7;
inline void IndirectPing::clear_sourceport() {
  sourceport_ = 0u;
}
inline uint32_t IndirectPing::_internal_sourceport() const {
  return sourceport_;
}
inline uint32_t IndirectPing::sourceport() const {
  // @@protoc_insertion_point(field_get:IndirectPing.SourcePort)
  return _internal_sourceport();
}
inline void IndirectPing::_internal_set_sourceport(uint32_t value) {
  
  sourceport_ = value;
}
inline void IndirectPing::set_sourceport(uint32_t value) {
  _internal_set_sourceport(value);
  // @@protoc_insertion_point(field_set:IndirectPing.SourcePort)
}

// string SourceNode = 8;
inline void IndirectPing::clear_sourcenode() {
  sourcenode_.ClearToEmpty();
}
inline const std::string& IndirectPing::sourcenode() const {
  // @@protoc_insertion_point(field_get:IndirectPing.SourceNode)
  return _internal_sourcenode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IndirectPing::set_sourcenode(ArgT0&& arg0, ArgT... args) {
 
 sourcenode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IndirectPing.SourceNode)
}
inline std::string* IndirectPing::mutable_sourcenode() {
  std::string* _s = _internal_mutable_sourcenode();
  // @@protoc_insertion_point(field_mutable:IndirectPing.SourceNode)
  return _s;
}
inline const std::string& IndirectPing::_internal_sourcenode() const {
  return sourcenode_.Get();
}
inline void IndirectPing::_internal_set_sourcenode(const std::string& value) {
  
  sourcenode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IndirectPing::_internal_mutable_sourcenode() {
  
  return sourcenode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IndirectPing::release_sourcenode() {
  // @@protoc_insertion_point(field_release:IndirectPing.SourceNode)
  return sourcenode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IndirectPing::set_allocated_sourcenode(std::string* sourcenode) {
  if (sourcenode != nullptr) {
    
  } else {
    
  }
  sourcenode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sourcenode,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sourcenode_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sourcenode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IndirectPing.SourceNode)
}

// -------------------------------------------------------------------

// AckResp

// uint32 SeqNo = 1;
inline void AckResp::clear_seqno() {
  seqno_ = 0u;
}
inline uint32_t AckResp::_internal_seqno() const {
  return seqno_;
}
inline uint32_t AckResp::seqno() const {
  // @@protoc_insertion_point(field_get:AckResp.SeqNo)
  return _internal_seqno();
}
inline void AckResp::_internal_set_seqno(uint32_t value) {
  
  seqno_ = value;
}
inline void AckResp::set_seqno(uint32_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:AckResp.SeqNo)
}

// -------------------------------------------------------------------

// NackResp

// uint32 SeqNo = 1;
inline void NackResp::clear_seqno() {
  seqno_ = 0u;
}
inline uint32_t NackResp::_internal_seqno() const {
  return seqno_;
}
inline uint32_t NackResp::seqno() const {
  // @@protoc_insertion_point(field_get:NackResp.SeqNo)
  return _internal_seqno();
}
inline void NackResp::_internal_set_seqno(uint32_t value) {
  
  seqno_ = value;
}
inline void NackResp::set_seqno(uint32_t value) {
  _internal_set_seqno(value);
  // @@protoc_insertion_point(field_set:NackResp.SeqNo)
}

// -------------------------------------------------------------------

// ErrResp

// string Error = 1;
inline void ErrResp::clear_error() {
  error_.ClearToEmpty();
}
inline const std::string& ErrResp::error() const {
  // @@protoc_insertion_point(field_get:ErrResp.Error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrResp::set_error(ArgT0&& arg0, ArgT... args) {
 
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ErrResp.Error)
}
inline std::string* ErrResp::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:ErrResp.Error)
  return _s;
}
inline const std::string& ErrResp::_internal_error() const {
  return error_.Get();
}
inline void ErrResp::_internal_set_error(const std::string& value) {
  
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ErrResp::_internal_mutable_error() {
  
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ErrResp::release_error() {
  // @@protoc_insertion_point(field_release:ErrResp.Error)
  return error_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ErrResp::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    
  } else {
    
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ErrResp.Error)
}

// -------------------------------------------------------------------

// Suspect

// uint32 Incarnation = 1;
inline void Suspect::clear_incarnation() {
  incarnation_ = 0u;
}
inline uint32_t Suspect::_internal_incarnation() const {
  return incarnation_;
}
inline uint32_t Suspect::incarnation() const {
  // @@protoc_insertion_point(field_get:Suspect.Incarnation)
  return _internal_incarnation();
}
inline void Suspect::_internal_set_incarnation(uint32_t value) {
  
  incarnation_ = value;
}
inline void Suspect::set_incarnation(uint32_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:Suspect.Incarnation)
}

// string Node = 2;
inline void Suspect::clear_node() {
  node_.ClearToEmpty();
}
inline const std::string& Suspect::node() const {
  // @@protoc_insertion_point(field_get:Suspect.Node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Suspect::set_node(ArgT0&& arg0, ArgT... args) {
 
 node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Suspect.Node)
}
inline std::string* Suspect::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:Suspect.Node)
  return _s;
}
inline const std::string& Suspect::_internal_node() const {
  return node_.Get();
}
inline void Suspect::_internal_set_node(const std::string& value) {
  
  node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Suspect::_internal_mutable_node() {
  
  return node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Suspect::release_node() {
  // @@protoc_insertion_point(field_release:Suspect.Node)
  return node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Suspect::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Suspect.Node)
}

// string From = 3;
inline void Suspect::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& Suspect::from() const {
  // @@protoc_insertion_point(field_get:Suspect.From)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Suspect::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Suspect.From)
}
inline std::string* Suspect::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:Suspect.From)
  return _s;
}
inline const std::string& Suspect::_internal_from() const {
  return from_.Get();
}
inline void Suspect::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Suspect::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Suspect::release_from() {
  // @@protoc_insertion_point(field_release:Suspect.From)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Suspect::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Suspect.From)
}

// -------------------------------------------------------------------

// Alive

// uint32 Incarnation = 1;
inline void Alive::clear_incarnation() {
  incarnation_ = 0u;
}
inline uint32_t Alive::_internal_incarnation() const {
  return incarnation_;
}
inline uint32_t Alive::incarnation() const {
  // @@protoc_insertion_point(field_get:Alive.Incarnation)
  return _internal_incarnation();
}
inline void Alive::_internal_set_incarnation(uint32_t value) {
  
  incarnation_ = value;
}
inline void Alive::set_incarnation(uint32_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:Alive.Incarnation)
}

// string Node = 2;
inline void Alive::clear_node() {
  node_.ClearToEmpty();
}
inline const std::string& Alive::node() const {
  // @@protoc_insertion_point(field_get:Alive.Node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alive::set_node(ArgT0&& arg0, ArgT... args) {
 
 node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Alive.Node)
}
inline std::string* Alive::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:Alive.Node)
  return _s;
}
inline const std::string& Alive::_internal_node() const {
  return node_.Get();
}
inline void Alive::_internal_set_node(const std::string& value) {
  
  node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Alive::_internal_mutable_node() {
  
  return node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Alive::release_node() {
  // @@protoc_insertion_point(field_release:Alive.Node)
  return node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Alive::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Alive.Node)
}

// string Addr = 3;
inline void Alive::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& Alive::addr() const {
  // @@protoc_insertion_point(field_get:Alive.Addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Alive::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Alive.Addr)
}
inline std::string* Alive::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:Alive.Addr)
  return _s;
}
inline const std::string& Alive::_internal_addr() const {
  return addr_.Get();
}
inline void Alive::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Alive::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Alive::release_addr() {
  // @@protoc_insertion_point(field_release:Alive.Addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Alive::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Alive.Addr)
}

// uint32 Port = 4;
inline void Alive::clear_port() {
  port_ = 0u;
}
inline uint32_t Alive::_internal_port() const {
  return port_;
}
inline uint32_t Alive::port() const {
  // @@protoc_insertion_point(field_get:Alive.Port)
  return _internal_port();
}
inline void Alive::_internal_set_port(uint32_t value) {
  
  port_ = value;
}
inline void Alive::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Alive.Port)
}

// -------------------------------------------------------------------

// Dead

// uint32 Incarnation = 1;
inline void Dead::clear_incarnation() {
  incarnation_ = 0u;
}
inline uint32_t Dead::_internal_incarnation() const {
  return incarnation_;
}
inline uint32_t Dead::incarnation() const {
  // @@protoc_insertion_point(field_get:Dead.Incarnation)
  return _internal_incarnation();
}
inline void Dead::_internal_set_incarnation(uint32_t value) {
  
  incarnation_ = value;
}
inline void Dead::set_incarnation(uint32_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:Dead.Incarnation)
}

// string Node = 2;
inline void Dead::clear_node() {
  node_.ClearToEmpty();
}
inline const std::string& Dead::node() const {
  // @@protoc_insertion_point(field_get:Dead.Node)
  return _internal_node();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dead::set_node(ArgT0&& arg0, ArgT... args) {
 
 node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Dead.Node)
}
inline std::string* Dead::mutable_node() {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:Dead.Node)
  return _s;
}
inline const std::string& Dead::_internal_node() const {
  return node_.Get();
}
inline void Dead::_internal_set_node(const std::string& value) {
  
  node_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Dead::_internal_mutable_node() {
  
  return node_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Dead::release_node() {
  // @@protoc_insertion_point(field_release:Dead.Node)
  return node_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Dead::set_allocated_node(std::string* node) {
  if (node != nullptr) {
    
  } else {
    
  }
  node_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (node_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    node_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Dead.Node)
}

// string From = 3;
inline void Dead::clear_from() {
  from_.ClearToEmpty();
}
inline const std::string& Dead::from() const {
  // @@protoc_insertion_point(field_get:Dead.From)
  return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Dead::set_from(ArgT0&& arg0, ArgT... args) {
 
 from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Dead.From)
}
inline std::string* Dead::mutable_from() {
  std::string* _s = _internal_mutable_from();
  // @@protoc_insertion_point(field_mutable:Dead.From)
  return _s;
}
inline const std::string& Dead::_internal_from() const {
  return from_.Get();
}
inline void Dead::_internal_set_from(const std::string& value) {
  
  from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Dead::_internal_mutable_from() {
  
  return from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Dead::release_from() {
  // @@protoc_insertion_point(field_release:Dead.From)
  return from_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Dead::set_allocated_from(std::string* from) {
  if (from != nullptr) {
    
  } else {
    
  }
  from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Dead.From)
}

// -------------------------------------------------------------------

// PushPull

// bool Join = 1;
inline void PushPull::clear_join() {
  join_ = false;
}
inline bool PushPull::_internal_join() const {
  return join_;
}
inline bool PushPull::join() const {
  // @@protoc_insertion_point(field_get:PushPull.Join)
  return _internal_join();
}
inline void PushPull::_internal_set_join(bool value) {
  
  join_ = value;
}
inline void PushPull::set_join(bool value) {
  _internal_set_join(value);
  // @@protoc_insertion_point(field_set:PushPull.Join)
}

// repeated .PushNodeState States = 2;
inline int PushPull::_internal_states_size() const {
  return states_.size();
}
inline int PushPull::states_size() const {
  return _internal_states_size();
}
inline void PushPull::clear_states() {
  states_.Clear();
}
inline ::PushNodeState* PushPull::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:PushPull.States)
  return states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PushNodeState >*
PushPull::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:PushPull.States)
  return &states_;
}
inline const ::PushNodeState& PushPull::_internal_states(int index) const {
  return states_.Get(index);
}
inline const ::PushNodeState& PushPull::states(int index) const {
  // @@protoc_insertion_point(field_get:PushPull.States)
  return _internal_states(index);
}
inline ::PushNodeState* PushPull::_internal_add_states() {
  return states_.Add();
}
inline ::PushNodeState* PushPull::add_states() {
  ::PushNodeState* _add = _internal_add_states();
  // @@protoc_insertion_point(field_add:PushPull.States)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PushNodeState >&
PushPull::states() const {
  // @@protoc_insertion_point(field_list:PushPull.States)
  return states_;
}

// -------------------------------------------------------------------

// PushNodeState

// string Name = 1;
inline void PushNodeState::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PushNodeState::name() const {
  // @@protoc_insertion_point(field_get:PushNodeState.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushNodeState::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PushNodeState.Name)
}
inline std::string* PushNodeState::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:PushNodeState.Name)
  return _s;
}
inline const std::string& PushNodeState::_internal_name() const {
  return name_.Get();
}
inline void PushNodeState::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PushNodeState::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PushNodeState::release_name() {
  // @@protoc_insertion_point(field_release:PushNodeState.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PushNodeState::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PushNodeState.Name)
}

// string Addr = 2;
inline void PushNodeState::clear_addr() {
  addr_.ClearToEmpty();
}
inline const std::string& PushNodeState::addr() const {
  // @@protoc_insertion_point(field_get:PushNodeState.Addr)
  return _internal_addr();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PushNodeState::set_addr(ArgT0&& arg0, ArgT... args) {
 
 addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PushNodeState.Addr)
}
inline std::string* PushNodeState::mutable_addr() {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:PushNodeState.Addr)
  return _s;
}
inline const std::string& PushNodeState::_internal_addr() const {
  return addr_.Get();
}
inline void PushNodeState::_internal_set_addr(const std::string& value) {
  
  addr_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PushNodeState::_internal_mutable_addr() {
  
  return addr_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PushNodeState::release_addr() {
  // @@protoc_insertion_point(field_release:PushNodeState.Addr)
  return addr_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PushNodeState::set_allocated_addr(std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), addr,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (addr_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    addr_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PushNodeState.Addr)
}

// uint32 Port = 3;
inline void PushNodeState::clear_port() {
  port_ = 0u;
}
inline uint32_t PushNodeState::_internal_port() const {
  return port_;
}
inline uint32_t PushNodeState::port() const {
  // @@protoc_insertion_point(field_get:PushNodeState.Port)
  return _internal_port();
}
inline void PushNodeState::_internal_set_port(uint32_t value) {
  
  port_ = value;
}
inline void PushNodeState::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:PushNodeState.Port)
}

// uint32 Incarnation = 4;
inline void PushNodeState::clear_incarnation() {
  incarnation_ = 0u;
}
inline uint32_t PushNodeState::_internal_incarnation() const {
  return incarnation_;
}
inline uint32_t PushNodeState::incarnation() const {
  // @@protoc_insertion_point(field_get:PushNodeState.Incarnation)
  return _internal_incarnation();
}
inline void PushNodeState::_internal_set_incarnation(uint32_t value) {
  
  incarnation_ = value;
}
inline void PushNodeState::set_incarnation(uint32_t value) {
  _internal_set_incarnation(value);
  // @@protoc_insertion_point(field_set:PushNodeState.Incarnation)
}

// .PushNodeState.NodeStateType State = 5;
inline void PushNodeState::clear_state() {
  state_ = 0;
}
inline ::PushNodeState_NodeStateType PushNodeState::_internal_state() const {
  return static_cast< ::PushNodeState_NodeStateType >(state_);
}
inline ::PushNodeState_NodeStateType PushNodeState::state() const {
  // @@protoc_insertion_point(field_get:PushNodeState.State)
  return _internal_state();
}
inline void PushNodeState::_internal_set_state(::PushNodeState_NodeStateType value) {
  
  state_ = value;
}
inline void PushNodeState::set_state(::PushNodeState_NodeStateType value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:PushNodeState.State)
}

// -------------------------------------------------------------------

// User

// string Msg = 1;
inline void User::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& User::msg() const {
  // @@protoc_insertion_point(field_get:User.Msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:User.Msg)
}
inline std::string* User::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:User.Msg)
  return _s;
}
inline const std::string& User::_internal_msg() const {
  return msg_.Get();
}
inline void User::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_msg() {
  // @@protoc_insertion_point(field_release:User.Msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:User.Msg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MessageData_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageData_MessageType>() {
  return ::MessageData_MessageType_descriptor();
}
template <> struct is_proto_enum< ::PushNodeState_NodeStateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PushNodeState_NodeStateType>() {
  return ::PushNodeState_NodeStateType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msgtype_2eproto
